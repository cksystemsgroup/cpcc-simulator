%%
%% Implementation
%%

\chapter{Implementation}

Thist chapter \ldots

\section{System Overview}

Figure~\ref{fig:SystemOverview} presents an overview of the complete system containing
one simulated \ac{RV} and the ground station.

The simulated \ac{RV} mainly comprises an Apache Tomcat web container, which executes a
Pilot web pplication and an Engine web application.
%
The Pilot web application consists of model helicopter plant simulator, that is, the MockJAviator,
a flight control system, an auto pilot, and a sensor simulator.
The MockJAviator emulates the helicopter's flight dynamics and \ac{IMU},
the flight control system operates attitude and altitude of the simulated vehicle, 
and the autopilot stirs the simulated vehicle along a \ac{VCL} script defined trajectory.
The sensor simulator supports GPS reveivers, belly mounted cameras, thermometers, barometers,
and sonar sensors.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=10cm]{SystemOverview.pdf}}
	\end{center}
	\caption{System Overview.\label{fig:SystemOverview}}
\end{figure}

The ground station executes an Apache Tomcat web container, which runs a Google Maps Viewer
web application, a Engine web application, and a Mapper web application.
%
The Google Maps Viewer web application allows an operator to supervise ongoing missions.
%
The ground station Engine web application provides a \ac{VV RTE} for uploading and downloading \acp{VV}. 
%
Registry and mapping algorithm are the main components of the Mapper web application.
The mapping algorithm assigns \acp{VV} to \acp{RV}, based on fight plans and available sensors.
%
Each Engine web application registers with the Mapper's registry.


\section{Sensor Simulation}
Figure~\ref{fig:SensorSimulation} visualizes the simulation of sensors.
%
The current implementation supports belly mounted cameras, random number generators for emulating thermometers and
barometers, GPS position sensors, and sonar sensors.

 
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=11.6cm]{SensorSimulation-3.pdf}}
	\end{center}
	\caption{Sensor Simulation.\label{fig:SensorSimulation}}
\end{figure}


The belly mounted camera delivers a Google Maps satellite image indicating the position of the simulated vehicle by a
visual marker, exemplified by Figure~\ref{fig:BellyMountedCamera}.
To achieve this, the Pilot web application supplies a JavaScript enhanced HTML page.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=6cm]{bmc-photo-cosy.png}}
	\end{center}
	\caption{A photo captured by the belly mounted camera.\label{fig:BellyMountedCamera}}
\end{figure}

Once the Firefox web browser selects this page, the embedded JavaScript program periodically polls the Pilot web
application for the vehicle's current position. After that, the JavaScript program slides the center of the
displayed satellite view to this position and repositions the marker.
To allow several belly mounted cameras beeing simulated on the same machine, the utilized web browsers use \ac{Xvfb}
devices as output screens.
%
Whenever the belly mounted camera needs to deliver a photo, it applies the \texttt{xwd} utility to take a snapshot
of the corresponding \ac{Xvfb} device, converts this snapshot to an image in PNG format by using program
\texttt{convert}, and delivers it via \ac{HTTP}.

Thermometer and air pressure sensors apply random number generators to simulate values.
The position sensor queries the GPS receiver simulator for the current position of the vehicle, and the sonar
sensor reads the current altitude over ground from the instantiated MockJAviator.


\section{Section}

\subsection{Subtitle}

Plain text.

\subsection{Another subtitle}

More plain text.


\section{Mapping}
The mapper is responsible for automatically mapping virtual vehicles to real vehicles. To accomplish this, the mechanism invokes 
the migration of virtual vehicles based on a mapping decision made by a mapper algorithm. The mapper is a a servlet and additionally 
to the mapper itself with its mapping algorithms, a registration service is present. The servlet can be suspended and stores all
registration information persistent in a file, otherwise registered engines would be lost. This is important because only registered 
engines are considered during the mapping process.

\subsection{Registration Service}
An engine registers itself with the registration service upon start up using its ID. If the registration was successful, the service
fetches some useful information and stores these together with the engine id. The fetched information are sensors and 
way points (flight plan), in our case, these are static informations. If a registration attempt was not successful, the engine 
keeps trying to register until it succeeds or it is terminated.

\subsection{Mapper}
The mapper itself is cyclic. It has a working and a sleeping cycle. \\
The working cycle consists of three steps:
\begin{tabbing}
1. fetch status \= of all virtual vehicles from all registered engines \\
\>	the status message includes: \= \\ 
\> \>					the next action point \\ 
\> \>					and its actions \\[0.25cm]
2. fetch status \= of all real vehicles (on which an engine is running) \\\>	the message includes:  \\
\> \>				the current position \\
\> \> 				the next position \\
\> \>				and the velocity \\[0.25cm]
3. execute the mapping algorithm \\
\end{tabbing}
At the time of writing, there are two algorithms available that can be set in the configuration file:
\subsubsection{Random Mapping Algorithm}
Does not use any information. Randomly selects two different engines. If one of these has a virtual vehicle, then this vehicle 
will be migrated to the other engine.

\subsubsection{Simple Mapping Algorithm}

	\begin{tabbing}
	\textbf{for} \= \textbf{all} virtual vehicles \textbf{do} \\[.25cm]
	\> \textbf{if}  \= virtual vehicle program is complete \\
	\> \>	\textbf{then} invoke migration to central engine \\[.25cm]
	\>	\textbf{else} \= find fastest real vehicle with at least one needed sensor \\
	\> \>	\textbf{and} distance CurrentToNext to ActionPoint \begin{math}< \end{math} tolerance \\[.25cm]
	\>	\textbf{if} found vehicle \textbf{then} invoke migration to it \\
	\end{tabbing}

Fastest vehicle means: the vehicle with the shortest flight time from its current position to the action point (thus: higher precision \begin{math} \rightarrow \end{math} faster)
of the virtual vehicle. 

conclusion:
A virtual vehicle stays on a real vehicle or the central engine as long as there is no suitable real vehicle, but such a vehicle can't 
be hidden by a non suitable vehicle.
