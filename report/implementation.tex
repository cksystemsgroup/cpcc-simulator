%%
%% Implementation
%%

\chapter{Implementation}

Thist chapter \ldots

\section{System Overview}

Figure~\ref{fig:SystemOverview} presents an overview of the complete system containing
one simulated \ac{RV} and the ground station.

The simulated \ac{RV} mainly comprises an Apache Tomcat web container, which executes a
Pilot web pplication and an Engine web application.
%
The Pilot web application consists of model helicopter plant simulator, that is, the MockJAviator,
a flight control system, an auto pilot, and a sensor simulator.
The MockJAviator emulates the helicopter's flight dynamics and \ac{IMU},
the flight control system operates attitude and altitude of the simulated vehicle, 
and the autopilot stirs the simulated vehicle along a \ac{VCL} script defined trajectory.
The sensor simulator supports GPS reveivers, belly mounted cameras, thermometers, barometers,
and sonar sensors.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=10cm]{SystemOverview.pdf}}
	\end{center}
	\caption{System Overview.\label{fig:SystemOverview}}
\end{figure}

The ground station executes an Apache Tomcat web container, which runs a Google Maps Viewer
web application, a Engine web application, and a Mapper web application.
%
The Google Maps Viewer web application allows an operator to supervise ongoing missions.
%
The ground station Engine web application provides a \ac{VV RTE} for uploading and downloading \acp{VV}. 
%
Registry and mapping algorithm are the main components of the Mapper web application.
The mapping algorithm assigns \acp{VV} to \acp{RV}, based on fight plans and available sensors.
%
Each Engine web application registers with the Mapper's registry.


\section{Sensor Simulation}
Figure~\ref{fig:SensorSimulation} visualizes the simulation of sensors.
%
The current implementation supports belly mounted cameras, random number generators for emulating thermometers and
barometers, GPS position sensors, and sonar sensors.

 
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=11.6cm]{SensorSimulation-3.pdf}}
	\end{center}
	\caption{Sensor Simulation.\label{fig:SensorSimulation}}
\end{figure}


The belly mounted camera delivers a Google Maps satellite image indicating the position of the simulated vehicle by a
visual marker, exemplified by Figure~\ref{fig:BellyMountedCamera}.
To achieve this, the Pilot web application supplies a JavaScript enhanced HTML page.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=6cm]{bmc-photo-cosy.png}}
	\end{center}
	\caption{A photo captured by the belly mounted camera.\label{fig:BellyMountedCamera}}
\end{figure}

Once the Firefox web browser selects this page, the embedded JavaScript program periodically polls the Pilot web
application for the vehicle's current position. After that, the JavaScript program slides the center of the
displayed satellite view to this position and repositions the marker.
To allow several belly mounted cameras beeing simulated on the same machine, the utilized web browsers use \ac{Xvfb}
devices as output screens.
%
Whenever the belly mounted camera needs to deliver a photo, it applies the \texttt{xwd} utility to take a snapshot
of the corresponding \ac{Xvfb} device, converts this snapshot to an image in PNG format by using program
\texttt{convert}, and delivers it via \ac{HTTP}.

Thermometer and air pressure sensors apply random number generators to simulate values.
The position sensor queries the GPS receiver simulator for the current position of the vehicle, and the sonar
sensor reads the current altitude over ground from the instantiated MockJAviator.

\section{Configuration}
This section covers the configuration of the web applications Pilot, Engine, Mapper, and GM-Viewer.

\subsection{Pilot Web Application}
The configuration of the Pilot web application consists of three parts. The first part is the configuration of the
simulated model helicopter hardware, the second part is the configuration of simulated sensors, and the third
part is the assigned \ac{VCL} script.

Listing~\ref{lst:virtHWconfig} depicts a fully simulated \ac{RV}. With the property \texttt{plant.simulated} equal
to \texttt{true}, the Pilot web application simulates the model helicopter's flight dynamics of the physical body
including the \ac{IMU}.
The simulated model helicopter of type \texttt{MockJAviator} 
awaits instructions via \acs{UDP} on address \texttt{localhost} port \texttt{9011} from a controller that
operates attitude and altitude. 
\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Virtual Hardware Configuration Example},mathescape=true,label=lst:virtHWconfig]{Name}
plant.simulated = true
plant.type = MockJAviator
plant.listener = udp://localhost:9011
plant.location.system.type = gpssim
plant.location.system.listener = tcp://localhost:9012
plant.location.system.update.rate = 10

controller.simulated = true
controller.type = JControl

pilot.type = JPilot
pilot.name = Pilot One
pilot.controller.connector = udp://localhost:9014
\end{lstlisting}
The simulated model helicopter has a simulated GPS receiver onboard, which listens on \texttt{localhost} port
\texttt{9012} for \acs{TCP} clients. It delivers the vehicle positions at a rate of 10 updates per second.  

In the configuration, shown in Listing~\ref{lst:virtHWconfig}, the
Pilot web application also emulates the controller for operating attitude and altitude. The controller uses
the property \texttt{plant.location.system.listener} to determine how to access the helicopter plant, and
uses the property \texttt{pilot.controller.connector} to identify the parameters for configuring a connection
for incoming commands.

The properties prefixed by \texttt{pilot} shows the type and name of the autopilot component, as well as
define the connection to the attitude and altitude controller.

Listing~\ref{lst:virtSensorConfig} depicts the configuration of simulated sensors. Property \texttt{sensor.list}
defines the sensors to be simulated. The names in this list prepended by \texttt{sensor} are part of the 
configuration that follows.
\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Sensor Configuration Example},mathescape=true,label=lst:virtSensorConfig]{Name}
sensor.list = gps, sonar, temp, photo

sensor.gps.name = GPS receiver
sensor.gps.path = position
sensor.gps.uri = gps:///

sensor.sonar.name = Sonar
sensor.sonar.path = sonar
sensor.sonar.uri = sonar:///

sensor.temp.name = Thermometer
sensor.temp.path = temperature
sensor.temp.uri = rand:///18/22
sensor.temp.precision = 1

sensor.photo.name = Belly Mounted Photo Camera
sensor.photo.path = photo
sensor.photo.uri = x11:///:21
sensor.photo.type = snapshot
\end{lstlisting}
Each sensor configuration defines a \texttt{name}, a \texttt{path}, and an \texttt{uri} parameter.
The parameter \texttt{name} of a sensor simply indicates its name and has no other impact whatsoever.
The parameter \texttt{path} is a suffix to an \acs{URL} dependent on the deployment context of the corresponding
Pilot web application. Let's assume, for example, the Pilot web application is deployed in a
web container's context \texttt{/pilot} listening on machine \texttt{nanook} port \texttt{9010}.
To access the Pilot web application, an operator uses the \acs{URL} \texttt{http://nanook:9010/pilot}. In this
example the \acs{URL} to access the above configured belly mounted photo camera is
\texttt{http://nanook:9010/pilot/sensor/photo}. 

GPS receiver and sonar sensor only have the protocol part of their \acs{URI} specified to indicate their data source.
The thermometer utilizes a random number generator to simulate values between \unit{18}{\celsius} and
\unit{22}{\celsius} providing a precision of one decimal digit.  
The belly mounted photo camera captures snapshots of the X11 screen identified by display number 21.

Listing~\ref{lst:VclExample} illustrates a \ac{VCL} script example. 
The character \texttt{\#} indicates lines containing comments.
%
The first command in this example, ``\texttt{go auto}'', switches the vehicle into autopilot mode. Without
this command, all following commands are ignored. Command ``\texttt{takeoff}'' starts the vehicle's engines
and lifts it off the ground to an altitude of \unit{1}{\meter} within \unit{5}{\second}.
%
The ``\texttt{fly to}'' commands define waypoints the vehicle has to traverse by specifying latitude, longitude,
and altitude above ground in absolute values. Additionally, this commands define a certain precision to
determine when a waypoint has been reached, e.g., a sphere of \unit{1}{\meter} radius. Furthermore, this commands
assign an average velocity to approach waypoints, e.g., \unit{2}{\meter\per\second}.
% 
\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Vehicle Control Language Example},mathescape=true,label=lst:VclExample]{Name}
##
## @(#) real vehicle set course example
##
go auto
takeoff 1m for 5s
fly to (47.82204197, 13.04086670, 20)abs precision 1m 2mps
fly to (47.82206088, 13.04092035, 20)abs precision 1m 2mps
fly to (47.82195102, 13.04488063, 20)abs precision 1m 2mps
hover for 20s
land
go manual
\end{lstlisting}
%
After all waypoints have been traversed, command ``\texttt{hover}'' instructs the vehicle to hover at
the last waypoint for, in this example, \unit{20}{\second}. After that, command ``\texttt{land}'' directs
the vehicle to land. Finally, command ``\texttt{go manual}'' switches back to manual control.


\subsection{Engine Web Application}

As depicted in Listing~\ref{lst:engineConfig}, the Engine web application configuration consists
of two parameters. Parameter ``\texttt{pilot.url}'' specifies the Pilot web application the Engine
travels with, and parameter ``\texttt{mapper.registry.url}'' defines the Mapper registry service to
register with.
\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Engine Configuration Example},mathescape=true,label=lst:engineConfig]{Name}
pilot.url = http://localhost:9010/pilot
mapper.registry.url = http://localhost:9040/mapper/registry
\end{lstlisting}



\subsection{Mapper Web Application}
Since every Engine web application registers with the Mapper, the Mapper web application needs no
configuration parameters.



\subsection{GM-Viewer Web Application}
Currently, our Google Maps Viewer web application needs to know every Pilot web application
and every Engine web application. As shown in Listing~\ref{lst:gmViewerConfig}, the \acs{JSON} \cite{RFC_4627}
query service \acsp{URL} for the current position, the set course's list of waypoints, and the  
list of currently assigned vehicles have to be configured for each \ac{RV} carrying a Pilot and an Engine.   

\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Google Maps Viewer Configuration Example},mathescape=true,label=lst:gmViewerConfig]{Name}
pilot.list = one, two

pilot.one.name = Pilot One
pilot.one.position.url = \
	http://localhost:9010/pilot/json/position
pilot.one.waypoints.url = \
	http://localhost:9010/pilot/json/waypoints
pilot.one.vehicle.status.url = \
	http://localhost:9010/engine/json/vehicle

pilot.two.name = Pilot Two
pilot.two.position.url = \
	http://localhost:9020/pilot/json/position
pilot.two.waypoints.url = \
	http://localhost:9020/pilot/json/waypoints
pilot.two.vehicle.status.url = \
	http://localhost:9020/engine/json/vehicle
\end{lstlisting}



\section{Real Vehicles}


\section{Vehicle Virtualization}

%VV intro
A virtual vehicle is a software implementation providing an isolated environment to the end user of the service. Virtual vehicles are hosted on real vehicles and offer an abstracted interface to the host's functionality. It should be possible for the end user to specify the behaviour of virtual vehicles and the jobs that should be executed on them.

\subsection{Virtual Vehicle Language}

%VV language
For abstraction of services to end users a dedicated virtual vehicle program language has been defined. The language is targeted to be simple in usage. In Listing~\ref{lst:vvProgram} a sample program is shown. The program represents a list of commands. Each command consists of a point and a list of actions that have to be executed at this point. The point definition contains the geographic location (latitude, longitude, altitude) and the specification of a tolerance radius. The tolerance radius defines a sphere around the point in which the actions have to be performed.

\begin{lstlisting}[caption={Virtual Vehicle Sample Program},mathescape=true,label=lst:vvProgram]{Name}
Point 47.82201946 13.04082647 1.00 tolerance 12.3
Picture
Temperature

Point 47.82203026 13.04084659 25.00 tolerance 100
Temperature

Point 47.82211311 13.04076076 30.00 tolerance 1.2
Picture
\end{lstlisting}

%Scanner

% \begin{frame}\frametitle{Vehicle Virtualization}\framesubtitle{Scanner}
% \begin{itemize}
% \item lookahead of one
% \item double and integers
% \item keywords and variables
% \item easy to add keywords - (prepared for adding if, else, while, for ...)
% \end{itemize} 
% \end{frame}

%Parser

% \begin{frame}\frametitle{Vehicle Virtualization}\framesubtitle{Parser}
% \begin{itemize}
% \item process symbols of scanner
% \item parser handles 
% \begin{itemize}
%   \item command (position, actions)
%   \item position (point, tolerance)
%   \item point (lat. long. alt.)
%   \item actions  
% \end{itemize} 
% \item error handling
% \begin{itemize}
%   \item throws parser exception with description
%   \item stop parsing
% \end{itemize} 
% \end{itemize} 
% \end{frame}

\subsection{Migration}

%suspend, persist, migrate resume, cyber/physical mobility
Virtual vehicles have the ability to suspend while they are executing their job. In this mode the entire internal state information is persisted to a file. While beeing in the suspended state it is possible to migrate the virtual vehicle to another real vehicle host and resume the operation there. 



% 
% \begin{frame}\frametitle{Vehicle Virtualization}\framesubtitle{Saving State}
% \begin{itemize}
% \item java serialisation used
% \item file with state
% \item list of commands with actions serialized
% \item already collected data in seperate file
% \end{itemize} 
% \end{frame}

% \begin{frame}\frametitle{Vehicle Virtualization}\framesubtitle{Execution of VV}
% \begin{itemize}
% \item VV are dispatched through 
% \item execute function
% \item read state, execute, store state
% \item partial execution of commands supported
% \end{itemize} 
% \end{frame}

\subsection{Types of Mobility}
The migration process is denominated as \emph{cyber mobility} because no real vehicle movement is taking place when the virtual vehicle changes its position. On the other side movements that are carried out on board of a not changing real vehicle host are known as \emph{physical mobilty}.



\section{Mapping}
The Mapper is responsible for automatically mapping \acp{VV} to \acp{RV}. To accomplish this, the mechanism invokes 
the migration of \acp{VV} based on a mapping decision made by a mapping algorithm. The Mapper is a servlet and
additionally to the Mapper itself with its mapping algorithm, a registration service is present. The servlet can be suspended and stores all
registration information persistent in a file, otherwise registered Engines would be lost. This is important because only registered 
Engines are considered during the mapping process.

\subsection{Registration Service}
An Engine registers itself with the registration service upon start up using its ID. If the registration was successful, the service
fetches some useful information and stores these together with the Engine ID. The fetched information are sensors and 
way points (flight plan), in our case, these are static informations. If a registration attempt was not successful, the Engine 
keeps trying to register until it succeeds or it is terminated.

\subsection{Mapper}
The mapper itself is cyclic. It has a working and a sleeping cycle.
The working cycle consists of three steps:

% \begin{tabbing}
% 1. fetch status \= of all virtual vehicles from all registered Engines \\
% \>	the status message includes: \= \\ 
% \> \>					the next action point \\ 
% \> \>					and its actions \\[0.25cm]
% 2. fetch status \= of all real vehicles (on which an Engine is running) \\
% \>	the message includes:  \\
% \> \>				the current position \\
% \> \> 				the next position \\
% \> \>				and the velocity \\[0.25cm]
% 3. execute the mapping algorithm \\
% \end{tabbing}

\begin{enumerate}
  \item Fetch the status of all \acp{VV} from all registered Engines.
  
  The status message includes the next action point, and its unfinished actions.
  
  \item Fetch the status of all \acp{RV} on which an Engine is running.
  
  The message includes the current position, the next position, and the average velocity
  
  \item Execute the mapping algorithm.
\end{enumerate}

At the time of writing, there are two algorithms available that can be set in the configuration file: a random
mapping algorithm and a simple mapping algorithm.

\subsubsection{Random Mapping Algorithm}
This algorithm does not use any information concerning flight plans and available sensors.
It randomly selects two different Engines. If one of these has a \ac{VV}, then this \ac{VV} will be
migrated to the other Engine.

\subsubsection{Simple Mapping Algorithm}

% 	\begin{tabbing}
% 	\textbf{for} \= \textbf{all} virtual vehicles \textbf{do} \\[.25cm]
% 	\> \textbf{if}  \= virtual vehicle program is complete \\
% 	\> \>	\textbf{then} invoke migration to central Engine \\[.25cm]
% 	\>	\textbf{else} \= find fastest real vehicle with at least one needed sensor \\
% 	\> \>	\textbf{and} distance CurrentToNext to ActionPoint \begin{math}< \end{math} tolerance \\[.25cm]
% 	\>	\textbf{if} found vehicle \textbf{then} invoke migration to it \\
% 	\end{tabbing}

Listing~\ref{lst:simpleMappingAlgorithm} reveals the simple mapping algorithm as pseudo code. 

\lstset{tabsize=3,language=PseudoCode}
\begin{lstlisting}[caption={Simple Mapping Algorithm},mathescape=true,label=lst:simpleMappingAlgorithm]{Name}
for all virtual vehicles do
	if virtual vehicle program is complete
	then
		invoke migration to central engine
	else
		find fastest real vehicle with at least one needed sensor
		and distance CurrentToNext to ActionPoint < tolerance
	endif
	if found vehicle 
	then 
		invoke migration to it 
	endif
endfor
\end{lstlisting}

Fastest vehicle means: the vehicle with the shortest flight time from its current position to the action point (thus: higher precision \begin{math} \rightarrow \end{math} faster)
of the virtual vehicle. 

conclusion:
A virtual vehicle stays on a real vehicle or the central Engine as long as there is no suitable real vehicle, but such a vehicle can't 
be hidden by a non suitable vehicle.
