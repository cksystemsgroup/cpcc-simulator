%%
%% Implementation
%%

\chapter{Implementation}

This chapter presents the implementation of our system.
After outlining the structural elements, it briefly describes the simulation of sensors and explains
configuration parameters. Then, this chapter describes vehicle virtualization, and elaborates on cyber-mobility.

\section{System Overview}

Figure~\ref{fig:SystemOverview} presents an overview of the complete system containing
the ground station and one simulated helicopter referred to as \ac{RV}.

The simulated \ac{RV} mainly comprises an Apache Tomcat web container, which executes a
Pilot web application and an Engine web application.
%
The Pilot web application consists of a model helicopter plant simulator, that is, the MockJAviator,
a flight control system, an auto pilot, and a sensor simulator.
The MockJAviator emulates the helicopter's flight dynamics and \ac{IMU},
the flight control system operates attitude and altitude of the simulated vehicle, 
and the autopilot stirs the simulated vehicle along a \ac{VCL} script defined trajectory.
The sensor simulator supports GPS receivers, belly mounted cameras, thermometers, barometers,
and sonar sensors.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=10cm]{SystemOverview.pdf}}
	\end{center}
	\caption{System Overview.\label{fig:SystemOverview}}
\end{figure}

The ground station executes an Apache Tomcat web container, which runs a Google Maps Viewer
web application, a Engine web application, and a Mapper web application.
%
The Google Maps Viewer web application allows an operator to supervise ongoing missions.
%
The ground station Engine web application provides a \ac{VV RTE} for uploading and downloading \acp{VV}. 
%
Registry and mapping algorithm are the main components of the Mapper web application.
The mapping algorithm assigns \acp{VV} to \acp{RV}, based on fight plans and available sensors.
%
Each Engine web application registers with the Mapper's registry.


\section{Sensor Simulation}
Figure~\ref{fig:SensorSimulation} visualizes the simulation of sensors.
%
The current implementation supports belly mounted cameras, random number generators for emulating thermometers and
barometers, GPS position sensors, and sonar sensors.

 
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=11.6cm]{SensorSimulation-3.pdf}}
	\end{center}
	\caption{Sensor Simulation.\label{fig:SensorSimulation}}
\end{figure}


The belly mounted camera delivers a Google Maps satellite image indicating the position of the simulated vehicle by a
visual marker, exemplified by Figure~\ref{fig:BellyMountedCamera}.
To achieve this, the Pilot web application supplies a JavaScript enhanced HTML page.
\begin{figure}[h]
	\begin{center}
		{\includegraphics[width=6cm]{bmc-photo-cosy.png}}
	\end{center}
	\caption{A photo captured by the belly mounted camera.\label{fig:BellyMountedCamera}}
\end{figure}

Once the Firefox web browser selects this page, the embedded JavaScript program periodically polls the Pilot web
application for the vehicle's current position. After that, the JavaScript program slides the center of the
displayed satellite view to this position and repositions the marker.
To allow several belly mounted cameras being simulated on the same machine, the utilized web browsers use \ac{Xvfb}
devices as output screens.
%
Whenever the belly mounted camera needs to deliver a photo, it applies the \texttt{xwd} utility to take a snapshot
of the corresponding \ac{Xvfb} device, converts this snapshot to an image in PNG format by using program
\texttt{convert}, and delivers it via \ac{HTTP}.

Thermometer and air pressure sensors apply random number generators to simulate values.
The position sensor queries the GPS receiver simulator for the current position of the vehicle, and the sonar
sensor reads the current altitude over ground from the instantiated MockJAviator.

\section{Configuration}
This section covers the configuration of the web applications Pilot, Engine, Mapper, and GM-Viewer.

\subsection{Pilot Web Application}
The configuration of the Pilot web application consists of three parts. The first part is the configuration of the
simulated model helicopter hardware, the second part is the configuration of simulated sensors, and the third
part is the assigned \ac{VCL} script.

Listing~\ref{lst:virtHWconfig} depicts a fully simulated \ac{RV}. With the property \texttt{plant.simulated} equal
to \texttt{true}, the Pilot web application simulates the model helicopter's flight dynamics of the physical body
including the \ac{IMU}.
The simulated model helicopter of type \texttt{MockJAviator} 
awaits instructions via \acs{UDP} on address \texttt{localhost} port \texttt{9011} from a controller that
operates attitude and altitude. 
\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Virtual Hardware Configuration Example},mathescape=true,label=lst:virtHWconfig]{Name}
plant.simulated = true
plant.type = MockJAviator
plant.listener = udp://localhost:9011
plant.location.system.type = gpssim
plant.location.system.listener = tcp://localhost:9012
plant.location.system.update.rate = 10

controller.simulated = true
controller.type = JControl

pilot.type = JPilot
pilot.name = Pilot One
pilot.controller.connector = udp://localhost:9014
\end{lstlisting}
The simulated model helicopter has a simulated GPS receiver onboard, which listens on \texttt{localhost} port
\texttt{9012} for \acs{TCP} clients. It delivers the vehicle positions at a rate of 10 updates per second.  

In the configuration, shown in Listing~\ref{lst:virtHWconfig}, the
Pilot web application also emulates the controller for operating attitude and altitude. The controller uses
the property \texttt{plant.location.system.listener} to determine how to access the helicopter plant, and
uses the property \texttt{pilot.controller.connector} to identify the parameters for configuring a connection
for incoming commands.

The properties prefixed by \texttt{pilot} shows the type and name of the autopilot component, as well as
define the connection to the attitude and altitude controller.

Listing~\ref{lst:virtSensorConfig} depicts the configuration of simulated sensors. Property \texttt{sensor.list}
defines the sensors to be simulated. The names in this list prepended by \texttt{sensor} are part of the 
configuration that follows.
\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Sensor Configuration Example},mathescape=true,label=lst:virtSensorConfig]{Name}
sensor.list = gps, sonar, temp, photo

sensor.gps.name = GPS receiver
sensor.gps.path = position
sensor.gps.uri = gps:///

sensor.sonar.name = Sonar
sensor.sonar.path = sonar
sensor.sonar.uri = sonar:///

sensor.temp.name = Thermometer
sensor.temp.path = temperature
sensor.temp.uri = rand:///18/22
sensor.temp.precision = 1

sensor.photo.name = Belly Mounted Photo Camera
sensor.photo.path = photo
sensor.photo.uri = x11:///:21
sensor.photo.type = snapshot
\end{lstlisting}
Each sensor configuration defines a \texttt{name}, a \texttt{path}, and an \texttt{uri} parameter.
The parameter \texttt{name} of a sensor simply indicates its name and has no other impact whatsoever.
The parameter \texttt{path} is a suffix to an \acs{URL} dependent on the deployment context of the corresponding
Pilot web application. Let's assume, for example, the Pilot web application is deployed in a
web container's context \texttt{/pilot} listening on machine \texttt{nanook} port \texttt{9010}.
To access the Pilot web application, an operator uses the \acs{URL} \texttt{http://nanook:9010/pilot}. In this
example the \acs{URL} to access the above configured belly mounted photo camera is
\texttt{http://nanook:9010/pilot/sensor/photo}. 

GPS receiver and sonar sensor only have the protocol part of their \acs{URI} specified to indicate their data source.
The thermometer utilizes a random number generator to simulate values between \unit{18}{\celsius} and
\unit{22}{\celsius} providing a precision of one decimal digit.  
The belly mounted photo camera captures snapshots of the X11 screen identified by display number 21.

Listing~\ref{lst:VclExample} illustrates a \ac{VCL} script example. 
The character \texttt{\#} indicates lines containing comments.
%
The first command in this example, ``\texttt{go auto}'', switches the vehicle into autopilot mode. Without
this command, all following commands are ignored. Command ``\texttt{takeoff}'' starts the vehicle's engines
and lifts it off the ground to an altitude of \unit{1}{\meter} within \unit{5}{\second}.
%
The ``\texttt{fly to}'' commands define waypoints the vehicle has to traverse by specifying latitude, longitude,
and altitude above ground in absolute values. Additionally, this commands define a certain precision to
determine when a waypoint has been reached, e.g., a sphere of \unit{1}{\meter} radius. Furthermore, this commands
assign an average velocity to approach waypoints, e.g., \unit{2}{\meter\per\second}.
% 
\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Vehicle Control Language Example},mathescape=true,label=lst:VclExample]{Name}
##
## @(#) real vehicle set course example
##
go auto
takeoff 1m for 5s
fly to (47.82204197, 13.04086670, 20)abs precision 1m 2mps
fly to (47.82206088, 13.04092035, 20)abs precision 1m 2mps
fly to (47.82195102, 13.04488063, 20)abs precision 1m 2mps
hover for 20s
land
go manual
\end{lstlisting}
%
As soon as all waypoints have been traversed, command ``\texttt{hover}'' instructs the vehicle to hold its
position at the last waypoint for, in this example, \unit{20}{\second}. After that, command ``\texttt{land}''
directs the vehicle to land. Finally, command ``\texttt{go manual}'' switches back to manual control.


\subsection{Engine Web Application}

As depicted in Listing~\ref{lst:engineConfig}, the Engine web application configuration consists
of two parameters. Parameter ``\texttt{pilot.url}'' specifies the Pilot web application the Engine
travels with, and parameter ``\texttt{mapper.registry.url}'' defines the Mapper registry service to
register with.
\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Engine Configuration Example},mathescape=true,label=lst:engineConfig]{Name}
pilot.url = http://localhost:9010/pilot
mapper.registry.url = http://localhost:9040/mapper/registry
\end{lstlisting}



\subsection{Mapper Web Application}
Since every Engine web application registers with the Mapper, the Mapper web application needs no
configuration parameters.



\subsection{GM-Viewer Web Application}
Currently, our Google Maps Viewer web application needs to know every Pilot web application
and every Engine web application. As shown in Listing~\ref{lst:gmViewerConfig}, the \acs{JSON} \cite{RFC_4627}
query service \acsp{URL} for the current position, the set course's list of waypoints, and the  
list of currently assigned vehicles have to be configured for each \ac{RV} carrying a Pilot and an Engine.   

\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Google Maps Viewer Configuration Example},mathescape=true,label=lst:gmViewerConfig]{Name}
pilot.list = one, two

pilot.one.name = Pilot One
pilot.one.position.url = \
	http://localhost:9010/pilot/json/position
pilot.one.waypoints.url = \
	http://localhost:9010/pilot/json/waypoints
pilot.one.vehicle.status.url = \
	http://localhost:9010/engine/json/vehicle

pilot.two.name = Pilot Two
pilot.two.position.url = \
	http://localhost:9020/pilot/json/position
pilot.two.waypoints.url = \
	http://localhost:9020/pilot/json/waypoints
pilot.two.vehicle.status.url = \
	http://localhost:9020/engine/json/vehicle
\end{lstlisting}





\section{Vehicle Virtualization}

%VV intro
A \acf{VV} is a software implementation providing an isolated environment to the end user of the service. \acp{VV} are
hosted on \acfp{RV} and offer an abstracted interface to the host's functionality. It should be possible for the end
user to specify the behavior of \acp{VV} and the jobs that should be executed on them.

\subsection{Virtual Vehicle Programming Language}

%VV language
For abstraction of services to end users a dedicated \ac{VV} programming language has been defined. The language
is targeted to be simple in usage. Listing~\ref{lst:vvProgram} shows a program example. The program represents a
list of commands. Each command consists of a point and a list of actions that have to be executed at this point. The
point definition contains the geographic location (latitude, longitude, altitude) and the specification of a tolerance
radius. The tolerance radius defines a sphere around the point in which the actions have to be performed.

\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Virtual Vehicle Sample Program},mathescape=true,label=lst:vvProgram]{Name}
Point 47.82201946 13.04082647 1.00 tolerance 12.3
Picture
Temperature

Point 47.82203026 13.04084659 25.00 tolerance 100
Temperature

Point 47.82211311 13.04076076 30.00 tolerance 1.2
Picture
\end{lstlisting}

\subsection{Parsing Virtual Vehicle Programs}
When a \ac{VV} is activated the program file is read and parsed. The implemented scanner allows extending the 
language by adding control structures like ``if~(\ldots)~else'' or ``for~(\ldots)'' loops. Keywords can be added easily and
parsing of doubles, integers, and identifier is already implemented. 
%
Parsing is done based on on the EBNF specification, shown in Listing~\ref{lst:vvEBNF}.

\lstset{tabsize=3,language=Tex}
\begin{lstlisting}[caption={Virtual Vehicle EBNF},mathescape=true,label=lst:vvEBNF]{Name}
Command = Position Action-List
Position = Point Tolerance
Point = "Point" double double double
Tolerance = "Tolerance" double
Action-List = Action {Action}
Action = "Temperature" | "Picture" | "Airpressure" |
	"Altitude" | "Speed"
\end{lstlisting}


%If an error occurs during the parsing of the program file an exception is thrown. With the exception and detailed error
% description is provided. Parsing is stopped and the rest of the file ignored.
%If the file was successfully parsed then the parser returns a list of command objects.
%Each of this objects include a position object and a list of actions.

If an error occurs during program parsing, the parser stops and throws an exception. For easier debugging, the exception
contains a detailed error description. If the parser succeeds parsing the program, it returns a list of command objects.
Each of this objects contains a position and a list of actions.
A position includes a point with a tolerance as described above.

\subsection{Executing Virtual Vehicle Programs}

A \ac{RV} can host one or more \ac{VV}. The \acp{VV} on a \ac{RV} are scheduled in round robin manner for
execution. When a \ac{VV} is the first time scheduled, it takes the first command from the command list, which was
returned from the parser, and starts executing this command. A command can be executed if the position of the \ac{RV} is
equal to the position specified in the command and the actions (taking a picture, measuring the temperature, ...) could be done.
If it's not possible to finish a command, because of a wrong position or actions can not be done, the \ac{VV} keeps
active.


\subsection{Migration}

\acp{VV} have the ability to suspend while they are executing their job. In this mode the entire internal state 
information is persisted to a file. While being in the suspended state it is possible to migrate the \ac{VV} to another
\ac{RV} host and resume the operation there. To store the state the Java serialization is used. The whole command
list is serialized to a file. That means the already finished commands and the command that have to be executed. The
results of the executed actions are stored in different files. After migration when the state is read back the \ac{VV}
looks at the command list and begin again to execute commands. All commands which are already executed are skipped. The
\ac{VV} continue with the first unfinished command. Unfinished could also mean that some of the actions where already
executed.


\subsection{Types of Mobility}
The migration process is denominated as \emph{cyber mobility}, because no real vehicle movement is taking place when the
\ac{VV} changes its location. On the other side movements that are carried out on board of a not changing \ac{RV} host
are known as \emph{physical mobility}.

Each \ac{mobility} records its movements. This historical track is represented by a list of waypoints. Each waypoint
contains a timestamp, the geographic location and the name of the host. The host name is necessary to differ between
cyber mobility and physical mobility. Waypoints are stored when a \ac{VV} executes a cycle and its location has
changed more than a specific distance (physical mobility) or its host has changed (cyber mobility). With the information
that is stored in the track detailed analysis of \ac{VV} moving behavior will be possible.



\section{Mapping}
The Mapper is responsible for automatically mapping \acp{VV} to \acp{RV}. To accomplish this, the mechanism invokes 
the migration of \acp{VV} based on a mapping decision made by a mapping algorithm. The Mapper is a servlet and
additionally to the Mapper itself with its mapping algorithm, a registration service is present. The servlet can be suspended and stores all
registration information persistent in a file, otherwise registered Engines would be lost. This is important because only registered 
Engines are considered during the mapping process.

\subsection{Registration Service}
An Engine registers itself with the registration service upon start up using its ID. If the registration was successful, the service
fetches some useful information and stores these together with the Engine ID. The fetched information are sensors and 
way points (flight plan), in our case, these is static information. If a registration attempt was not successful, the
Engine keeps trying to register until it succeeds.

\subsection{Mapper}
The mapper periodically executes the following three steps: 

\begin{enumerate}
  \item Fetch the status of all \acp{VV} from all registered Engines.
  The status message includes the next action point, and its unfinished actions.
  
  \item Fetch the status of all \acp{RV} on which an Engine is running.
  The returned message includes the current position, the next position, and the average velocity
  
  \item Execute the mapping algorithm.
\end{enumerate}

At the time of writing, there are two algorithms available that can be set in the configuration file: a random
mapping algorithm and a simple mapping algorithm.

\subsubsection{Random Mapping Algorithm}
This algorithm does not use any information concerning flight plans and available sensors.
It randomly selects two different Engines. If one of these has a \ac{VV}, then this \ac{VV} will be
migrated to the other Engine.

\subsubsection{Simple Mapping Algorithm}

Listing~\ref{lst:simpleMappingAlgorithm} reveals the simple mapping algorithm as pseudo code. 

\lstset{tabsize=3,language=PseudoCode}
\begin{lstlisting}[caption={Simple Mapping Algorithm},mathescape=true,label=lst:simpleMappingAlgorithm]{Name}
for all virtual vehicles do
	if virtual vehicle program is complete
	then
		invoke migration to central engine
	else
		find fastest real vehicle with at least one needed sensor
		and distance CurrentToNext to ActionPoint < tolerance
	endif
	if found vehicle 
	then 
		invoke migration to it 
	endif
endfor
\end{lstlisting}

The fastest vehicle is the vehicle with the shortest flight time from its current position to the action
point of the \ac{VV}.
%(thus: higher precision \begin{math} \rightarrow \end{math} faster) of the virtual vehicle. 


Figure~\ref{fig:intersectionExample} shows the current flight path, the current location $C$ of a \ac{RV} and the 
end point of the current flight plan segment $N$.
% Illustration of line segment to action point distance:
\begin{figure}[h]
	\begin{center}
		{
            \includegraphics[width=12cm]{dist.eps}
        }
	\end{center}
	\caption{Intersection of flight path and next action point.\label{fig:intersectionExample}}
\end{figure}
% This example 
The flight path $\displaystyle{\overrightarrow{CN}}$ intersects with the tolerance sphere of action point $AP$, thus
the distance is smaller than the tolerance and the \ac{RV} is a candidate for migration.

With this behavior of the algorithm, a \ac{VV} stays on a \ac{RV} or the central Engine until a \ac{RV}
enters a flight plan segment that satisfies the \ac{VV}'s sensor and location requirements.


